import{get_request_store as v,with_request_store as E}from"@sveltejs/kit/internal/server";import{error as q,json as T}from"@sveltejs/kit";import{b as k,f as R,e as D,t as J,n as x,g as U,h as A,s as F,D as H,c as I}from"./chunks/shared.js";import{ValidationError as N}from"@sveltejs/kit/internal";import{b as V,c as W,p as S}from"./chunks/environment.js";function O(e,i){if(!i)return t=>{t!==void 0&&q(400,"Bad Request")};if(e==="unchecked")return t=>t;if("~standard"in e)return async t=>{const{event:r,state:s}=v(),u=await e["~standard"].validate(t);return u.issues&&q(400,await s.handleValidationError({issues:u.issues,event:r})),u.value};throw new Error('Invalid validator passed to remote function. Expected "unchecked" or a Standard Schema (https://standardschema.dev)')}async function j(e,i,t,r){await 0;const s=g(e,t);return s[k(i,t.transport)]??=r()}async function _(e,i,t,r,s,u){const n={event:{...e,setHeaders:()=>{throw new Error("setHeaders is not allowed in remote functions")},cookies:{...e.cookies,set:(d,c,f)=>{if(!t)throw new Error("Cannot set cookies in `query` or `prerender` functions");if(f.path&&!f.path.startsWith("/"))throw new Error("Cookies set in remote functions must have an absolute path");return e.cookies.set(d,c,f)},delete:(d,c)=>{if(!t)throw new Error("Cannot delete cookies in `query` or `prerender` functions");if(c.path&&!c.path.startsWith("/"))throw new Error("Cookies deleted in remote functions must have an absolute path");return e.cookies.delete(d,c)}}},state:{...i,is_in_remote_function:!0}},a=await E(n,()=>s(r));return E(n,()=>u(a))}function g(e,i=v().state){let t=i.remote_data?.get(e);return t===void 0&&(t={},(i.remote_data??=new Map).set(e,t)),t}function Y(e,i){const t=i??e,r=O(e,i),s={type:"command",id:"",name:""},u=n=>{const{event:a,state:d}=v();if(d.is_endpoint_request){if(!["POST","PUT","PATCH","DELETE"].includes(a.request.method))throw new Error(`Cannot call a command (\`${s.name}(${i?"...":""})\`) from a ${a.request.method} handler`)}else if(!a.isRemoteRequest)throw new Error(`Cannot call a command (\`${s.name}(${i?"...":""})\`) during server-side rendering`);d.refreshes??={};const c=Promise.resolve(_(a,d,!0,n,r,t));return c.updates=()=>{throw new Error(`Cannot call '${s.name}(...).updates(...)' on the server`)},c};return Object.defineProperty(u,"__",{value:s}),Object.defineProperty(u,"pending",{get:()=>0}),u}function Z(e,i){const t=i??e,r=!i||e==="unchecked"?null:e;function s(u){const n={};n.method="POST",Object.defineProperty(n,"enhance",{value:()=>({action:n.action,method:n.method})});const a={type:"submit",onclick:()=>{}};Object.defineProperty(a,"enhance",{value:()=>({type:"submit",formaction:n.buttonProps.formaction,onclick:()=>{}})}),Object.defineProperty(n,"buttonProps",{value:a});const d={type:"form",name:"",id:"",fn:async(c,f,l)=>{if(!c){const p=()=>{throw new Error("Remote form functions no longer get passed a FormData object. `form` now has the same signature as `query` or `command`, i.e. it expects to be invoked like `form(schema, callback)` or `form('unchecked', callback)`. The payload of the callback function is now a POJO instead of a FormData object. See https://kit.svelte.dev/docs/remote-functions#form for details.")};c={};for(const w of["append","delete","entries","forEach","get","getAll","has","keys","set","values"])Object.defineProperty(c,w,{get:p})}const o={};o.submission=!0;const{event:m,state:h}=v(),y=await r?.["~standard"].validate(c);if(f.validate_only)return y?.issues?.map(p=>x(p,!0))??[];if(y?.issues!==void 0)C(o,y.issues,l);else{y!==void 0&&(c=y.value),h.refreshes??={};const p=M();try{o.result=await _(m,h,!0,c,w=>w,w=>i?t(w,p):t())}catch(w){if(w instanceof N)C(o,w.issues,l);else throw w}}return m.isRemoteRequest||(g(d,h)[""]??=o),o}};return Object.defineProperty(n,"__",{value:d}),Object.defineProperty(n,"action",{get:()=>`?/remote=${d.id}`,enumerable:!0}),Object.defineProperty(a,"formaction",{get:()=>`?/remote=${d.id}`,enumerable:!0}),Object.defineProperty(n,"fields",{get(){const c=g(d)?.[""],f=R(c?.issues??[]);return D({},()=>c?.input??{},(l,o)=>{if(c?.submission)return;const m=l.length===0?o:A(c?.input??{},l.map(String),o);(g(d)[""]??={}).input=m},()=>f)}}),J(n),Object.defineProperty(n,"result",{get(){try{return g(d)?.[""]?.result}catch{return}}}),Object.defineProperty(n,"pending",{get:()=>0}),Object.defineProperty(a,"pending",{get:()=>0}),Object.defineProperty(n,"preflight",{value:()=>n}),Object.defineProperty(n,"validate",{value:()=>{throw new Error("Cannot call validate() on the server")}}),u==null&&Object.defineProperty(n,"for",{value:c=>{const{state:f}=v(),l=d.id+"|"+JSON.stringify(c);let o=(f.form_instances??=new Map).get(l);return o||(o=s(c),o.__.id=`${d.id}/${encodeURIComponent(JSON.stringify(c))}`,o.__.name=d.name,f.form_instances.set(l,o)),o}}),n}return s()}function C(e,i,t){if(e.issues=i.map(r=>x(r,!0)),t){e.input={};for(let r of t.keys()){if(/^[.\]]?_/.test(r))continue;const s=r.endsWith("[]"),u=t.getAll(r).filter(n=>typeof n=="string");s&&(r=r.slice(0,-2)),U(e.input,r,s?u:u[0])}}}function M(){return new Proxy(t=>{if(typeof t!="string")throw new Error("`invalid` should now be imported from `@sveltejs/kit` to throw validation issues. The second parameter provided to the form function (renamed to `issue`) is still used to construct issues, e.g. `invalid(issue.field('message'))`. For more info see https://github.com/sveltejs/kit/pulls/14768");return e(t)},{get(t,r){return typeof r=="symbol"?t[r]:i(r,[])}});function e(t,r=[]){return{message:t,path:r}}function i(t,r){const s=[...r,t],u=n=>e(n,s);return new Proxy(u,{get(n,a){return typeof a=="symbol"?n[a]:/^\d+$/.test(a)?i(parseInt(a,10),s):i(a,s)}})}}function ee(e,i,t){const r=typeof i=="function"?i:void 0,s=t??(r?void 0:i),u=r??e,n=O(e,r),a={type:"prerender",id:"",name:"",has_arg:!!r,inputs:s?.inputs,dynamic:s?.dynamic},d=c=>{const f=(async()=>{const{event:l,state:o}=v(),m=k(c,o.transport),h=a.id,y=`${V}/${W}/remote/${h}${m?`/${m}`:""}`;if(!o.prerendering&&H,o.prerendering?.remote_responses.has(y))return o.prerendering.remote_responses.get(y);const p=j(a,c,o,()=>_(l,o,!1,c,n,u));o.prerendering&&o.prerendering.remote_responses.set(y,p);const w=await p;if(o.prerendering){const $={type:"result",result:F(w,o.transport)};o.prerendering.dependencies.set(y,{body:JSON.stringify($),response:T($)})}return w})();return f.catch(()=>{}),f};return Object.defineProperty(d,"__",{value:a}),d}function z(e,i){const t=i??e,r=O(e,i),s={type:"query",id:"",name:""},u=n=>{if(S)throw new Error(`Cannot call query '${s.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:a,state:d}=v(),c=()=>_(a,d,!1,n,r,t),f=j(s,n,d,c);return f.catch(()=>{}),f.set=l=>P(b(s,"set",n),l),f.refresh=()=>{const l=b(s,"refresh",n),o=!l.cache[l.cache_key],m=o?f:c();return P(l,m,o)},f.withOverride=()=>{throw new Error(`Cannot call '${s.name}.withOverride()' on the server`)},f};return Object.defineProperty(u,"__",{value:s}),u}function B(e,i){const t=i??e,r=O(e,i),s={type:"query_batch",id:"",name:"",run:a=>{const{event:d,state:c}=v();return _(d,c,!1,a,f=>Promise.all(f.map(r)),t)}};let u={args:[],resolvers:[]};const n=a=>{if(S)throw new Error(`Cannot call query.batch '${s.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:d,state:c}=v(),f=()=>new Promise((o,m)=>{u.args.push(a),u.resolvers.push({resolve:o,reject:m}),!(u.args.length>1)&&setTimeout(async()=>{const h=u;u={args:[],resolvers:[]};try{const y=await _(d,c,!1,h.args,p=>Promise.all(p.map(r)),t);for(let p=0;p<h.resolvers.length;p++)try{h.resolvers[p].resolve(y(h.args[p],p))}catch(w){h.resolvers[p].reject(w)}}catch(y){for(const p of h.resolvers)p.reject(y)}},0)}),l=j(s,a,c,f);return l.catch(()=>{}),l.set=o=>P(b(s,"set",a),o),l.refresh=()=>{const o=b(s,"refresh",a),m=!o.cache[o.cache_key],h=m?l:f();return P(o,h,m)},l.withOverride=()=>{throw new Error(`Cannot call '${s.name}.withOverride()' on the server`)},l};return Object.defineProperty(n,"__",{value:s}),n}Object.defineProperty(z,"batch",{value:B,enumerable:!0});function b(e,i,t){const{state:r}=v(),{refreshes:s}=r;if(!s){const d=e.type==="query_batch"?`query.batch '${e.name}'`:`query '${e.name}'`;throw new Error(`Cannot call ${i} on ${d} because it is not executed in the context of a command/form remote function`)}const u=g(e,r),n=k(t,r.transport),a=I(e.id,n);return{__:e,state:r,refreshes:s,refreshes_key:a,cache:u,cache_key:n}}function P({__:e,refreshes:i,refreshes_key:t,cache:r,cache_key:s},u,n=!1){const a=Promise.resolve(u);return n||(r[s]=a),e.id&&(i[t]=a),a.then(()=>{})}export{Y as command,Z as form,ee as prerender,z as query};
