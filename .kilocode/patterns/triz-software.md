# TRIZ in Software Engineering

> Теория решения изобретательских задач (ТРИЗ), адаптированная для разработки ПО.

## Основные концепции

### 1. Идеальный Конечный Результат (ИКР / IFR)
**Принцип:** Лучшая система — это та, которой нет, но её функции выполняются.
**Применение в коде:**
- Код, который не нужно писать (использование существующих библиотек, платформенных возможностей).
- Архитектура, которая не требует поддержки (serverless, managed services).
- "Функция выполняется сама" (автоматическая сборка мусора, декларативное программирование).

**Вопрос:** Как получить результат без написания нового кода/модуля/сервиса?

### 2. Разрешение противоречий (Contradictions)
В разработке часто возникают технические противоречия (например, скорость vs потребление памяти).

**Типовые приемы разрешения:**

| Прием ТРИЗ | Адаптация для ПО | Пример |
|------------|------------------|--------|
| **Принцип дробления** | Микросервисы, компонентизация, шардинг БД | Разбить монолит на сервисы для независимого деплоя. |
| **Принцип вынесения** | Выделение "узких мест" в отдельные сервисы | Вынести тяжелую обработку изображений в отдельный worker. |
| **Принцип местного качества** | Оптимизация только hot paths, разные БД для разных задач | Redis для кэша, Postgres для надежности. |
| **Принцип асимметрии** | Асинхронная обработка, CQRS | Read model отличается от Write model. |
| **Принцип объединения** | Паттерн Facade, API Gateway, Aggregator | Объединить вызовы нескольких микросервисов в один endpoint. |
| **Принцип универсальности** | Полиморфизм, Generics, Duck typing | Один код работает с разными типами данных. |
| **Принцип "матрешки"** | Декораторы, Middleware, вложенные транзакции | Обернуть функцию логирования вокруг бизнес-логики. |
| **Принцип предварительного исполнения** | Кэширование, прекомпиляция, AOT | Сгенерировать статику во время билда, а не в рантайме. |

### 3. Законы развития технических систем
1. **Закон повышения идеальности:** Системы стремятся к уменьшению затрат при сохранении функциональности (Refactoring, Optimization).
2. **Закон перехода в надсистему:** Модуль становится частью платформы (Library -> Framework -> Language Feature).

## Алгоритм решения задач (АРИЗ-Light для ПО)

1. **Сформулировать проблему:** Что не устраивает? (Медленно работает)
2. **Определить ИКР:** Скорость мгновенная, ресурсов ноль.
3. **Выявить противоречие:** Чтобы было быстро, нужно много памяти (кэш), но памяти мало.
4. **Применить приемы:**
   - *Разделение во времени:* Кэшировать только то, что часто запрашивается.
   - *Изменение состояния:* Использовать сжатие данных (Trade-off CPU vs Memory).
5. **Оценить решение:** Насколько близко к ИКР?

## TRIZ vs DRY/SOLID
Если возникает конфликт между принципами (например, DRY требует общей абстракции, а TRIZ подсказывает разделение для разрешения противоречия):
- **Приоритет:** ИКР (Идеальный результат).
- Если дублирование кода (нарушение DRY) позволяет системе работать быстрее и проще поддерживаться (приближение к ИКР) — **нарушаем DRY**.
- Если абстракция усложняет систему (удаление от ИКР) — **отказываемся от абстракции** (KISS/YAGNI).