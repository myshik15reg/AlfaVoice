# RabbitMQ - Правила интеграции для 1С

## Обзор

RabbitMQ используется для асинхронного обмена данными между системами 1С и внешними приложениями. Данный документ описывает стандарты именования, конфигурации и паттерны интеграции.

## Именование

### Virtual Hosts (vhosts)

Формат: `<ТипСреды>_<КодПроекта>`

```
PROD_ALFA           # Продакшн Альфа-Лизинг
TEST_ALFA           # Тестовая среда
DEV_ALFA            # Разработка
PROD_ALFA_DR        # Disaster Recovery
```

### Exchanges (Обмены)

Формат: `<проект>.<тип>`

```
alfa.direct         # Прямая маршрутизация
alfa.topic          # Топиковая маршрутизация
alfa.fanout         # Широковещательная рассылка
alfa.headers        # Маршрутизация по заголовкам
```

**Типы обменов:**

| Тип | Использование |
|-----|---------------|
| `direct` | Точная маршрутизация по routing key |
| `topic` | Маршрутизация по шаблону |
| `fanout` | Рассылка всем очередям |
| `headers` | Маршрутизация по заголовкам сообщения |

### Queues (Очереди)

Формат: `queue.from.<приложение>.to.<потребитель>.<типОбъекта>.<событие>`

```
queue.from.CRM.to.ERP.user.changed
queue.from.CRM.to.ERP.insurance_quote.created
queue.from.ERP.to.CRM.contract.approved
queue.from.ERP.to.DWH.transaction.completed
queue.from.WEB.to.CRM.lead.submitted
```

**Компоненты:**
- `from.<приложение>` — источник сообщения (CRM, ERP, WEB, MOBILE)
- `to.<потребитель>` — получатель сообщения
- `<типОбъекта>` — тип бизнес-объекта (user, contract, lead, etc.)
- `<событие>` — тип события (created, changed, deleted, approved)

### Routing Keys (Ключи маршрутизации)

Формат: `{типОбъекта}.{типКоманды}.{событие}`

```
user.event.changed
user.event.created
user.event.deleted
contract.command.approve
contract.command.reject
contract.event.approved
contract.event.rejected
insurance_quote.event.created
insurance_quote.command.calculate
```

**Типы команд:**
- `event` — событие (уже произошло)
- `command` — команда (требуется выполнить)
- `query` — запрос данных

## Конфигурация

### Стандартная конфигурация очереди

```json
{
  "name": "queue.from.CRM.to.ERP.user.changed",
  "durable": true,
  "exclusive": false,
  "auto_delete": false,
  "arguments": {
    "x-message-ttl": 86400000,
    "x-max-length": 100000,
    "x-max-length-bytes": 104857600,
    "x-overflow": "reject-publish",
    "x-dead-letter-exchange": "alfa.dlx",
    "x-dead-letter-routing-key": "user.event.changed.dlq"
  }
}
```

**Параметры:**

| Параметр | Значение | Описание |
|----------|----------|----------|
| `durable` | `true` | Очередь сохраняется при перезапуске |
| `x-message-ttl` | `86400000` | TTL сообщения (24 часа в мс) |
| `x-max-length` | `100000` | Максимум сообщений в очереди |
| `x-max-length-bytes` | `104857600` | Максимум байт (100 MB) |
| `x-overflow` | `reject-publish` | Поведение при переполнении |
| `x-dead-letter-exchange` | `alfa.dlx` | Exchange для DLQ |

### Dead Letter Queue (DLQ)

Для каждой очереди создаётся DLQ для обработки ошибок:

```
queue.from.CRM.to.ERP.user.changed         # Основная очередь
queue.from.CRM.to.ERP.user.changed.dlq     # Dead Letter Queue
```

### Конфигурация обмена

```json
{
  "exchange": "alfa.direct",
  "type": "direct",
  "durable": true,
  "auto_delete": false,
  "internal": false,
  "arguments": {}
}
```

## Формат сообщений

### Структура сообщения

```json
{
  "header": {
    "messageId": "550e8400-e29b-41d4-a716-446655440000",
    "correlationId": "550e8400-e29b-41d4-a716-446655440001",
    "timestamp": "2025-12-28T10:30:00.000Z",
    "source": "CRM",
    "version": "1.0",
    "contentType": "application/json"
  },
  "body": {
    "eventType": "user.changed",
    "objectType": "User",
    "objectId": "12345",
    "data": {
      "id": "12345",
      "name": "Иванов Иван Иванович",
      "email": "ivanov@example.com",
      "phone": "+7 (999) 123-45-67",
      "changedFields": ["name", "email"]
    },
    "metadata": {
      "userId": "admin",
      "sessionId": "abc123",
      "ipAddress": "192.168.1.100"
    }
  }
}
```

### Заголовки (Headers)

| Заголовок | Обязательный | Описание |
|-----------|--------------|----------|
| `messageId` | ✅ | Уникальный ID сообщения (UUID) |
| `correlationId` | ⚠️ | ID для связи запрос-ответ |
| `timestamp` | ✅ | Время создания (ISO 8601) |
| `source` | ✅ | Источник сообщения |
| `version` | ✅ | Версия формата сообщения |
| `contentType` | ✅ | Тип содержимого |

## Реализация в 1С

### Отправка сообщения

```bsl
/// @description Отправляет сообщение в RabbitMQ
/// @param {Строка} RoutingKey - Ключ маршрутизации
/// @param {Структура} Данные - Данные для отправки
/// @returns {Булево} Успех отправки
/// @task УЗ-12345
Функция ОтправитьСообщение(RoutingKey, Данные) Экспорт

    Попытка

        // Формируем сообщение
        Сообщение = Новый Структура;

        // Заголовок
        Заголовок = Новый Структура;
        Заголовок.Вставить("messageId", Строка(Новый УникальныйИдентификатор));
        Заголовок.Вставить("timestamp", XMLСтрока(ТекущаяДатаСеанса()));
        Заголовок.Вставить("source", "ERP");
        Заголовок.Вставить("version", "1.0");
        Заголовок.Вставить("contentType", "application/json");

        Сообщение.Вставить("header", Заголовок);
        Сообщение.Вставить("body", Данные);

        // Сериализуем в JSON
        ЗаписьJSON = Новый ЗаписьJSON;
        ЗаписьJSON.УстановитьСтроку();
        ЗаписатьJSON(ЗаписьJSON, Сообщение);
        ТелоСообщения = ЗаписьJSON.Закрыть();

        // Отправляем через HTTP API RabbitMQ
        НастройкиПодключения = ал_НастройкиRabbitMQ.ПолучитьНастройки();

        HTTPСоединение = Новый HTTPСоединение(
            НастройкиПодключения.Хост,
            НастройкиПодключения.Порт,
            НастройкиПодключения.Пользователь,
            НастройкиПодключения.Пароль,
            ,
            30
        );

        URL = СтрШаблон("/api/exchanges/%1/%2/publish",
            НастройкиПодключения.VHost,
            НастройкиПодключения.Exchange);

        ТелоЗапроса = Новый Структура;
        ТелоЗапроса.Вставить("properties", Новый Структура);
        ТелоЗапроса.Вставить("routing_key", RoutingKey);
        ТелоЗапроса.Вставить("payload", ТелоСообщения);
        ТелоЗапроса.Вставить("payload_encoding", "string");

        ЗаписьJSON = Новый ЗаписьJSON;
        ЗаписьJSON.УстановитьСтроку();
        ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);

        HTTPЗапрос = Новый HTTPЗапрос(URL);
        HTTPЗапрос.УстановитьТелоИзСтроки(ЗаписьJSON.Закрыть());
        HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json");

        HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);

        Если HTTPОтвет.КодСостояния = 200 ИЛИ HTTPОтвет.КодСостояния = 204 Тогда
            Возврат Истина;
        Иначе
            ал_Логирование.ЗаписатьОшибку("RabbitMQ",
                "Ошибка отправки: " + HTTPОтвет.КодСостояния);
            Возврат Ложь;
        КонецЕсли;

    Исключение
        ал_Логирование.ЗаписатьОшибку("RabbitMQ", ОписаниеОшибки());
        Возврат Ложь;
    КонецПопытки;

КонецФункции
```

### Получение сообщений

```bsl
/// @description Получает сообщения из очереди RabbitMQ
/// @param {Строка} ИмяОчереди - Имя очереди для чтения
/// @param {Число} МаксКоличество - Максимальное количество сообщений
/// @returns {Массив} Массив сообщений
/// @task УЗ-12345
Функция ПолучитьСообщения(ИмяОчереди, МаксКоличество = 100) Экспорт

    Сообщения = Новый Массив;

    Попытка

        НастройкиПодключения = ал_НастройкиRabbitMQ.ПолучитьНастройки();

        HTTPСоединение = Новый HTTPСоединение(
            НастройкиПодключения.Хост,
            НастройкиПодключения.Порт,
            НастройкиПодключения.Пользователь,
            НастройкиПодключения.Пароль
        );

        URL = СтрШаблон("/api/queues/%1/%2/get",
            НастройкиПодключения.VHost,
            ИмяОчереди);

        ТелоЗапроса = Новый Структура;
        ТелоЗапроса.Вставить("count", МаксКоличество);
        ТелоЗапроса.Вставить("ackmode", "ack_requeue_false");
        ТелоЗапроса.Вставить("encoding", "auto");

        ЗаписьJSON = Новый ЗаписьJSON;
        ЗаписьJSON.УстановитьСтроку();
        ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);

        HTTPЗапрос = Новый HTTPЗапрос(URL);
        HTTPЗапрос.УстановитьТелоИзСтроки(ЗаписьJSON.Закрыть());
        HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/json");

        HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);

        Если HTTPОтвет.КодСостояния = 200 Тогда
            ТелоОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
            ЧтениеJSON = Новый ЧтениеJSON;
            ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
            ПолученныеСообщения = ПрочитатьJSON(ЧтениеJSON);

            Для Каждого СообщениеRMQ Из ПолученныеСообщения Цикл
                Сообщение = РазобратьСообщение(СообщениеRMQ.payload);
                Если Сообщение <> Неопределено Тогда
                    Сообщения.Добавить(Сообщение);
                КонецЕсли;
            КонецЦикла;
        КонецЕсли;

    Исключение
        ал_Логирование.ЗаписатьОшибку("RabbitMQ", ОписаниеОшибки());
    КонецПопытки;

    Возврат Сообщения;

КонецФункции
```

### Обработка событий

```bsl
/// @description Обрабатывает событие изменения пользователя
/// @param {Структура} Сообщение - Сообщение из очереди
/// @returns {Булево} Успех обработки
/// @task УЗ-12345
Функция ОбработатьИзменениеПользователя(Сообщение) Экспорт

    Попытка

        Данные = Сообщение.body.data;

        // Находим контрагента по внешнему ID
        Контрагент = Справочники.Контрагенты.НайтиПоРеквизиту(
            "ВнешнийИдентификатор",
            Данные.id
        );

        Если НЕ ЗначениеЗаполнено(Контрагент) Тогда
            // Создаём нового
            КонтрагентОбъект = Справочники.Контрагенты.СоздатьЭлемент();
            КонтрагентОбъект.ВнешнийИдентификатор = Данные.id;
        Иначе
            КонтрагентОбъект = Контрагент.ПолучитьОбъект();
        КонецЕсли;

        // Обновляем данные
        Если Данные.Свойство("name") Тогда
            КонтрагентОбъект.Наименование = Данные.name;
        КонецЕсли;

        Если Данные.Свойство("email") Тогда
            КонтрагентОбъект.Email = Данные.email;
        КонецЕсли;

        Если Данные.Свойство("phone") Тогда
            КонтрагентОбъект.Телефон = Данные.phone;
        КонецЕсли;

        КонтрагентОбъект.Записать();

        Возврат Истина;

    Исключение
        ал_Логирование.ЗаписатьОшибку(
            "ОбработкаСообщения",
            ОписаниеОшибки(),
            Сообщение.header.messageId
        );
        Возврат Ложь;
    КонецПопытки;

КонецФункции
```

## Паттерны интеграции

### Request-Reply

```
Запрос:  contract.query.get-details
Ответ:   contract.reply.details

Очереди:
- queue.from.WEB.to.ERP.contract.query
- queue.from.ERP.to.WEB.contract.reply
```

### Publish-Subscribe

```
Событие: contract.event.approved

Подписчики:
- queue.from.ERP.to.CRM.contract.approved
- queue.from.ERP.to.DWH.contract.approved
- queue.from.ERP.to.NOTIFY.contract.approved
```

### Saga Pattern

Для сложных бизнес-процессов используется паттерн Saga:

```
1. contract.command.create
2. contract.event.created
3. approval.command.start
4. approval.event.started
5. approval.event.completed
6. contract.command.activate
7. contract.event.activated
```

## Мониторинг и алерты

### Метрики для мониторинга

| Метрика | Порог | Алерт |
|---------|-------|-------|
| Queue depth | > 10000 | Warning |
| Queue depth | > 50000 | Critical |
| Message age | > 1 hour | Warning |
| Message age | > 24 hours | Critical |
| Consumer count | = 0 | Critical |
| Publish rate | < 1/min | Warning |

### Healthcheck

```bsl
/// @description Проверяет доступность RabbitMQ
/// @returns {Структура} Статус подключения
Функция ПроверитьПодключение() Экспорт

    Результат = Новый Структура;
    Результат.Вставить("Доступен", Ложь);
    Результат.Вставить("Сообщение", "");

    Попытка
        НастройкиПодключения = ал_НастройкиRabbitMQ.ПолучитьНастройки();

        HTTPСоединение = Новый HTTPСоединение(
            НастройкиПодключения.Хост,
            НастройкиПодключения.Порт,
            НастройкиПодключения.Пользователь,
            НастройкиПодключения.Пароль,
            ,
            5
        );

        HTTPЗапрос = Новый HTTPЗапрос("/api/healthchecks/node");
        HTTPОтвет = HTTPСоединение.Получить(HTTPЗапрос);

        Если HTTPОтвет.КодСостояния = 200 Тогда
            Результат.Доступен = Истина;
            Результат.Сообщение = "OK";
        Иначе
            Результат.Сообщение = "HTTP " + HTTPОтвет.КодСостояния;
        КонецЕсли;

    Исключение
        Результат.Сообщение = ОписаниеОшибки();
    КонецПопытки;

    Возврат Результат;

КонецФункции
```

## Checklist

- [ ] Имена очередей соответствуют стандарту
- [ ] Routing keys соответствуют формату
- [ ] Настроен DLQ для каждой очереди
- [ ] Сообщения содержат обязательные заголовки
- [ ] Реализована обработка ошибок
- [ ] Настроен мониторинг очередей
- [ ] Документированы все интеграционные контракты
