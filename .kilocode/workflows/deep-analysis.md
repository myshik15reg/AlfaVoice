# Workflow: Глубокий анализ кода (deep-analysis)

## Описание
Этот рабочий процесс выполняет регулярный анализ проектов через методику AlfaFlow: подготовка контекста, мысленный прогон (Mental Simulation), верификация, формирование отчета и предложение следующих шагов. Позволяет выявить скрытые проблемы, слабые места в архитектуре и потенциальные улучшения.

## Параметры
- `analysis_aspect`: Аспект анализа (опционально, по умолчанию: `all`)
  - Возможные значения: `typization`, `error-handling`, `performance`, `architecture`, `security`, `patterns`, `code-smells`, `overengineering`, `all`
- `scenario`: Сценарий для анализа (опционально, по умолчанию: полный цикл обработки запроса/события)
  - Примеры: "обработка HTTP-запроса", "создание нового пользователя", "обработка WebSocket-сообщения"
- `target_scope`: Область анализа (опционально, по умолчанию: весь проект)
  - Примеры: "src/api/", "src/core/", конкретные файлы или модули

---

## Шаг 1: Подготовка контекста (Context Prep)

**Цель:** Получить полное понимание текущего состояния проекта через чтение Memory Bank и ключевых файлов.

**Промпт (appendix-1):**
```
Ты — эксперт по анализу кода. Твоя задача — подготовить контекст для глубокого анализа проекта.

Выполни следующие действия:

1. Прочитай все файлы из `.kilocode/rules/memory-bank/`:
   - `context.md` — текущий фокус работы
   - `product.md` — цели продукта и проблемы пользователей
   - `architecture.md` — архитектурные решения и паттерны
   - `tech.md` — технологический стек
   - `context.md` — статус проекта и roadmap

2. Изучи структуру проекта:
   - Получи список файлов (используй `list_files` с рекурсивным перечислением)
   - Определи основные модули и слои архитектуры
   - Построй ментальную карту зависимостей

3. Определи ключевые конфигурационные файлы:
   - `package.json` или аналоги (зависимости, скрипты)
   - `tsconfig.json` или аналоги (настройки типизации)
   - Файлы сборки и конфигурации

4. Сформируй краткое резюме контекста:
   - Тип проекта и его назначение
   - Основные технологии
   - Архитектурные паттерны
   - Текущий статус разработки
   - Активные протоколы (если есть)
```

**Действия:**
1. Прочитать все файлы из `.kilocode/rules/memory-bank/`
2. Изучить структуру директорий проекта
3. Прочитать ключевые конфигурационные файлы
4. Определить основные модули/слои архитектуры
5. Построить ментальную карту зависимостей между модулями

**Проверка:** Понимание общей структуры проекта, целей продукта, архитектурных решений и текущего статуса

---

## Шаг 2: Мысленный прогон (Mental Simulation)

**Цель:** Пройти по цепочке выполнения сценария, анализируя каждый модуль на пути с учетом всех аспектов качества кода.

**Промпт (appendix-2):**
```
Ты — эксперт по анализу кода. Твоя задача — выполнить мысленный прогон (Mental Simulation) указанного сценария.

Выполни следующие действия:

### 2.1. Определение потока выполнения
1. Определи точку входа для указанного сценария
2. Пройди по цепочке вызовов от входа до выхода:
   - Для каждого модуля: какие данные он получает, что возвращает
   - Какие побочные эффекты происходят (I/O, внешние вызовы, изменение состояния)
   - Какие зависимости задействованы
3. Веди детальный "след" выполнения:
   - Поток данных (data flow)
   - Поток управления (control flow)
   - Точки ветвления и условия
4. Определи критические участки:
   - Места, где возможны ошибки
   - Места с высокой сложностью
   - Места с потенциальными узкими местами производительности

### 2.2. Анализ аспектов качества кода

Для каждого критического участка проанализируй следующие аспекты:

#### 2.2.1. Проблемы в коде (Code Issues)
- Логические ошибки
- Некорректное использование API
- Потенциальные баги
- Race conditions
- Deadlock scenarios

#### 2.2.2. Паттерны и анти-паттерны (Patterns & Anti-patterns)
- Использование известных паттернов (SOLID, GoF, Enterprise patterns)
- Наличие анти-паттернов (God Object, Spaghetti Code, Magic Numbers, etc.)
- Соответствие архитектурным паттернам проекта
- Нарушение принципов проектирования

#### 2.2.3. Code Smells
- Дублирование кода (DRY violations)
- Длинные методы/функции
- Большое количество параметров
- Глубокая вложенность
- Избыточная сложность (Cyclomatic Complexity)
- Плохие имена переменных/функций
- Отсутствие комментариев там, где они нужны
- Комментарии, объясняющие очевидное

#### 2.2.4. Оверинжиниринг (Overengineering)
- Избыточная абстракция
- Преждевременная оптимизация
- Сложность без необходимости
- Over-design (YAGNI violations)
- Использование паттернов там, где не нужно

#### 2.2.5. Типизация (Type Safety)
- Наличие `any`, `unknown` и слабых типов
- Согласованность типов на стыках модулей
- Покрытие типами всех возвращаемых значений и параметров
- Корректность использования generic типов
- Неявные приведения типов

#### 2.2.6. Обработка ошибок (Error Handling)
- Наличие try-catch блоков в критических местах
- Корректность обработки исключений
- Логирование информации об ошибках
- Сохранение контекста ошибки (stack trace, дополнительные данные)
- Обработка граничных случаев (null, пустые значения, превышение лимитов)

#### 2.2.7. Производительность (Performance)
- Алгоритмическая сложность (вложенные циклы O(n²) и выше)
- Эффективность структур данных
- N+1 запросы к базе данных
- Отсутствие кэширования тяжелых операций
- Утечки памяти
- Использование lazy loading/streaming

#### 2.2.8. Безопасность (Security)
- Валидация входных данных
- Защита от SQL-инъекций, XSS, CSRF
- Безопасность аутентификации и авторизации
- Защита чувствительных данных
- Правильная обработка ошибок (не раскрывать внутренности)

#### 2.2.9. Тестируемость (Testability)
- Возможность написания unit тестов
- Наличие моков для внешних зависимостей
- Изоляция бизнес-логики от I/O
- Отсутствие жестких зависимостей (tight coupling)

#### 2.2.10. Масштабируемость (Scalability)
- Возможность горизонтального масштабирования
- Узкие места в архитектуре
- Поддержка распределенного выполнения
- Состояние (stateless vs stateful)

### 2.3. Проверка инвариантов
1. Определи бизнес-правила и инварианты системы:
   - Какие условия должны всегда выполняться
   - Какие ограничения на данные существуют
2. Проверь, где инварианты могут нарушиться:
   - При параллельных операциях
   - При частичных обновлениях данных
   - При ошибках в середине транзакции
3. Проверь защиту инвариантов:
   - Есть ли валидация на входе
   - Есть ли проверки в критических точках
   - Есть ли транзакции для атомарных операций

### 2.4. Формирование выводов
Для каждой найденной проблемы укажи:
- Категорию (Code Issues, Patterns, Code Smells, Overengineering, Typization, Error Handling, Performance, Security, Testability, Scalability)
- Локацию (файл:строка или модуль)
- Описание проблемы
- Почему это важно (обоснование)
- Рекомендацию по исправлению
- Приоритет (Critical, High, Medium, Low)
```

**Действия:**
1. Определить точку входа для указанного сценария
2. Пройти по цепочке вызовов от входа до выхода
3. Вести детальный "след" выполнения
4. Определить критические участки
5. Проанализировать все аспекты качества кода для каждого критического участка
6. Проверить инварианты системы
7. Сформировать список найденных проблем

**Проверка:** Полный след выполнения сценария от входа до выхода, анализ всех аспектов качества кода

---

## Шаг 3: Верификация (Verification)

**Цель:** Опциональная верификация результатов анализа другим агентом или тем же агентом с критическим подходом.

**Промпт (appendix-3):**
```
Ты — критический ревьюер. Твоя задача — проверить результаты анализа кода.

Выполни следующие действия:

1. Проверь полноту анализа:
   - Все ли аспекты были проанализированы
   - Нет ли пропущенных критических участков
   - Все ли файлы/модули были рассмотрены

2. Проверь обоснованность выводов:
   - Каждая проблема имеет четкое описание
   - Каждая проблема имеет обоснование важности
   - Каждая проблема имеет конкретную рекомендацию
   - Приоритеты присвоены корректно

3. Проверь практическую значимость:
   - Нет ли теоретических проблем без практического значения
   - Учитывается ли контекст масштаба данных/операций
   - Рекомендации выполнимы и реалистичны

4. Проверь соответствие контексту:
   - Анализ учитывает цели продукта (product.md)
   - Анализ учитывает архитектурные решения (architecture.md)
   - Анализ учитывает технологический стек (tech.md)

5. Сформируй вердикт:
   - Если есть пропуски или ошибки — укажи их
   - Если анализ полный и качественный — подтверди его
```

**Действия:**
1. Проверить полноту анализа
2. Проверить обоснованность выводов
3. Проверить практическую значимость
4. Проверить соответствие контексту
5. Сформировать вердикт верификации

**Проверка:** Верификация выполнена, вердикт сформирован

---

## Шаг 4: Формирование отчета (Report)

**Цель:** Сформировать структурированный отчет с найденными проблемами и рекомендациями.

**Промпт (appendix-4):**
```
Ты — эксперт по составлению отчетов. Твоя задача — сформировать итоговый отчет глубокого анализа кода.

Используй следующий формат отчета:

# Отчет глубокого анализа кода

## Метаданные
- **Дата анализа**: {дата}
- **Аспекты анализа**: {список аспектов}
- **Сценарий**: {описание сценария}
- **Область анализа**: {target_scope}
- **Вердикт верификации**: {подтвержден/требует доработки}

---

## Обзор контекста

### Тип проекта
{тип проекта и назначение}

### Технологический стек
{список основных технологий}

### Архитектурные паттерны
{используемые паттерны}

### Текущий статус
{статус разработки, активные протоколы}

---

## Обзор архитектуры

### Плюсы
- {пункт 1}
- {пункт 2}
- ...

### Минусы
- {пункт 1}
- {пункт 2}
- ...

---

## Найденные проблемы

### Критические (Critical)
Приоритет: Высокий. Требуют немедленного исправления.

1. **{Название проблемы}**
   - **Категория**: {Code Issues/Patterns/Code Smells/Overengineering/Typization/Error Handling/Performance/Security/Testability/Scalability}
   - **Локация**: `{файл}:{строка}` или модуль
   - **Описание**: {подробное описание}
   - **Почему это важно**: {обоснование важности}
   - **Рекомендация**: {как исправить}

### Важные (High)
Приоритет: Средний. Следует исправить в ближайшее время.

{аналогичный формат}

### Средние (Medium)
Приоритет: Низкий. Можно исправить при рефакторинге.

{аналогичный формат}

### Низкие (Low)
Приоритет: Очень низкий. Косметические улучшения.

{аналогичный формат}

---

## Статистика

| Категория | Critical | High | Medium | Low | Всего |
|-----------|----------|------|--------|-----|-------|
| Code Issues | {n} | {n} | {n} | {n} | {n} |
| Patterns & Anti-patterns | {n} | {n} | {n} | {n} | {n} |
| Code Smells | {n} | {n} | {n} | {n} | {n} |
| Overengineering | {n} | {n} | {n} | {n} | {n} |
| Typization | {n} | {n} | {n} | {n} | {n} |
| Error Handling | {n} | {n} | {n} | {n} | {n} |
| Performance | {n} | {n} | {n} | {n} | {n} |
| Security | {n} | {n} | {n} | {n} | {n} |
| Testability | {n} | {n} | {n} | {n} | {n} |
| Scalability | {n} | {n} | {n} | {n} | {n} |
| **Итого** | **{n}** | **{n}** | **{n}** | **{n}** | **{n}** |

---

## Рекомендации по улучшению

### Критические действия (немедленно)
1. **{Категория улучшения}**
   - {рекомендация 1}
   - {рекомендация 2}
   - ...

### Приоритетные улучшения (в ближайшее время)
{аналогичный формат}

### Рекомендуемые улучшения (при рефакторинге)
{аналогичный формат}

---

## Заключение

{краткое резюме и приоритеты действий}
```

**Действия:**
1. Сформировать структурированный отчет по указанному формату
2. Включить все найденные проблемы с приоритетами
3. Добавить статистику по категориям
4. Сформировать рекомендации по улучшению
5. Написать заключение с приоритетами действий

**Проверка:** Отчет сформирован, все аспекты включены

---

## Шаг 5: Следующие шаги (Next Steps)

**Цель:** Предложить пользователю следующие действия на основе результатов анализа.

**Промпт (appendix-5):**
```
Ты — эксперт по планированию разработки. Твоя задача — предложить следующие шаги на основе результатов анализа.

Выполни следующие действия:

1. Проанализируй найденные проблемы:
   - Сгруппируй проблемы по категориям
   - Определи взаимосвязи между проблемами
   - Оцени объем работ для каждой проблемы

2. Сформируй предложения по следующим шагам:
   - Если есть критические проблемы — предложи создать протокол для их исправления
   - Если есть важные проблемы — предложи включить их в roadmap
   - Если есть средние/низкие проблемы — предложи включить их в backlog

3. Для каждого предложенного протокола укажи:
   - Название протокола
   - Цель протокола
   - Критерии приемки (Definition of Done)
   - Примерный объем работ
   - Приоритет относительно других задач

4. Сформируй итоговое сообщение пользователю с предложениями.
```

**Действия:**
1. Проанализировать найденные проблемы
2. Сгруппировать проблемы по категориям
3. Оценить объем работ
4. Сформировать предложения по следующим шагам
5. Предложить создать протоколы для исправления проблем

**Проверка:** Предложения по следующим шагам сформированы

---

## Принципы анализа

### 1. Мысленный прогон (Mental Simulation)
- Всегда начинай с понимания полного потока выполнения
- Веди детальный след: какие данные, где, как преобразуются
- Не полагайся только на статический анализ — моделируй выполнение

### 2. Критическое мышление
- Задавай вопросы: "А что если...?" для каждой критической точки
- Не принимай ничего как должное — проверяй инварианты
- Ищи крайние случаи и граничные условия

### 3. Контекст масштаба
- При оценке производительности всегда указывай масштаб данных/операций
- Проблема при 100 записях может не быть проблемой при 10 записях
- Оценивай актуальность проблемы для реального использования

### 4. Практическая направленность
- Каждая проблема должна иметь конкретную рекомендацию
- Приоритизируй по влиянию на систему
- Избегай теоретических проблем без практического значения

### 5. Соответствие AlfaFlow
- Всегда читай Memory Bank перед анализом
- Учитывай архитектурные решения из architecture.md
- Учитывай цели продукта из product.md
- Предлагай протоколы для исправления проблем

---

## Примеры сценариев для анализа

### Web API
- "Обработка POST-запроса на создание пользователя"
- "Обработка GET-запроса с пагинацией"
- "Обработка ошибки валидации"

### Background Jobs
- "Обработка очереди задач"
- "Периодическая синхронизация данных"
- "Обработка webhook-уведомлений"

### Data Layer
- "Запись в базу данных с транзакцией"
- "Чтение с кэшированием"
- "Миграция данных"

### 1C:Предприятие
- "Обработка документа в 1С"
- "Проведение регламентной операции"
- "Интеграция с внешней системой"

---

## Интеграция с AlfaFlow

Этот workflow может быть использован:
- **Перед реализацией** протокола (Architect Mode) для анализа текущего состояния
- **После реализации** протокола (Code Reviewer Mode) для проверки качества кода
- **При ревью** Pull Request для глубокого анализа изменений
- **Регулярно** для периодического анализа проекта (рекомендуется раз в неделю/месяц)

### Сохранение результатов

При использовании в контексте протокола:
1. Сохраняй отчет в `.protocols/{protocol_number}-{task_name}/deep-analysis.md`
2. Обновляй `execution.md` с результатами анализа
3. Используй результаты для корректировки плана или кода

При регулярном анализе:
1. Сохраняй отчет в `.kilocode/rules/memory-bank/reviews/YYYY-MM-DD-deep-analysis.md`
2. Обновляй `context.md` с найденными проблемами
3. Предлагай протоколы для исправления критических проблем

### Связь с Memory Bank

- **context.md**: Читай перед началом анализа для понимания текущего фокуса
- **product.md**: Используй для понимания целей продукта и проблем пользователей
- **architecture.md**: Используй для проверки соответствия архитектурным решениям
- **tech.md**: Используй для понимания технологического стека
- **context.md**: Обновляй с найденными проблемами и предложениями

---

## Специализированные промпты для конкретных аспектов

### Промпт для анализа типизации (appendix-2-typization)
```
Выполни детальный анализ типизации кода:

1. Проверь наличие слабых типов:
   - Где используются `any`, `unknown` и почему
   - Можно ли уточнить типы
   - Есть ли неявные приведения типов

2. Проверь согласованность типов на стыках модулей:
   - Совпадают ли входные/выходные типы
   - Есть ли несоответствия в интерфейсах
   - Корректно ли передаются данные между модулями

3. Проверь покрытие типами:
   - Все ли возвращаемые значения типизированы
   - Есть ли пропущенные типы в параметрах функций
   - Используются ли optional types корректно

4. Проверь использование generic типов:
   - Корректность ограничений (constraints)
   - Избыточность или недостаточность обобщения
   - Правильность использования generic variance

5. Проверь типы данных:
   - Корректность использования примитивных типов
   - Использование пользовательских типов там, где нужно
   - Правильность использования union и intersection types
```

### Промпт для анализа обработки ошибок (appendix-2-error-handling)
```
Выполни детальный анализ обработки ошибок:

1. Для каждого критического участка задай вопрос: "А что если упадет здесь?"

2. Проверь обработку ошибок:
   - Есть ли try-catch блоки там, где нужны
   - Корректно ли обрабатываются исключения
   - Логируется ли информация об ошибках

3. Проверь распространение ошибок:
   - Возвращаются ли ошибки явно или пробрасываются
   - Сохраняется ли контекст ошибки (stack trace, дополнительные данные)
   - Есть ли потеря контекста при пробросе ошибок

4. Проверь граничные случаи:
   - Что происходит при пустых/null значениях
   - Что происходит при превышении лимитов
   - Что происходит при недоступности внешних сервисов

5. Проверь пользовательский опыт:
   - Понятны ли сообщения об ошибках
   - Есть ли возможность восстановления после ошибки
   - Логируется ли достаточно информации для отладки
```

---

## Пример использования

### Запуск анализа всего проекта
```
Параметры:
- analysis_aspect: all
- scenario: полный цикл обработки запроса
- target_scope: весь проект

Результат: Полный отчет по всем аспектам качества кода
```

### Запуск анализа конкретного аспекта
```
Параметры:
- analysis_aspect: typization
- scenario: обработка HTTP-запроса
- target_scope: src/api/

Результат: Отчет по типизации в API слое
```

### Запуск анализа конкретного сценария
```
Параметры:
- analysis_aspect: error-handling, performance
- scenario: создание нового пользователя
- target_scope: src/services/userService.ts

Результат: Отчет по обработке ошибок и производительности в сценарии создания пользователя
```
