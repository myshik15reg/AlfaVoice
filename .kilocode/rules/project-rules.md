# AlfaFlow Project Rules

## Основные принципы (Core Principles)

1. **Memory First**: Перед началом ЛЮБОЙ работы прочитай `.kilocode/memory-bank/index.md` и подтверди прочтение выводом строки `[MB: OK]`. Это БЛОКИРУЮЩЕЕ требование.
2. **No Protocol, No Code**: Не пиши код без активного протокола в `.protocols/`. Если протокола нет — переключись в Architect Mode и создай его.
3. **Update Plan**: После выполнения каждого шага обновляй `.protocols/.../plan.md`.
4. **Log Decisions**: Если столкнулся с проблемой и решил её нестандартно — запиши это в `.protocols/.../execution.md`.
5. **Clean Finish**: Перед завершении задачи убедись, что все тесты проходят, и попроси Architect Mode обновить Memory Bank.
6. **Context Isolation**: При работе над протоколом фокусируйся только на файлах, указанных в плане. Не меняй глобальную архитектуру без обновления `architecture.md`.
7. **Cleanup Policy**: Не оставлять после себя мусор в виде временных .md файлов, логов или легаси кода. Все временные артефакты должны удаляться после завершения задачи.
8. **ONE MODE PER TASK**: **КРИТИЧЕСКИ ВАЖНО!** Один таск = один режим. ЗАПРЕЩЕНО переключаться между режимами в рамках одной задачи. Если нужен другой режим — создай НОВУЮ ПОДЗАДАЧУ через `new_task`.
9. **Baby Steps Dynamic Planning**: Двигайся максимально мелкими, итеративными шагами. Если шаг сломал систему — откатись (Revert) и сделай шаг меньше.
10. **Design Principles**: Соблюдай SOLID, KISS, DRY, YAGNI. Применяй TRIZ и Emergent Design.
    - **Приоритет:** При конфликте (например, TRIZ vs DRY) приоритет отдается "Идеальному Конечному Результату" (TRIZ).
11. **Absolute Quality**: Качество важнее скорости. 100% покрытие тестами, отсутствие линтер-ворнингов и строгая типизация — это не "желательно", это "обязательно". Мы не идем на компромиссы с качеством.

-------

---

## Hybrid AI Strategy

### Роли моделей (Model Roles)

**Primary Model (Claude/Deep Reasoning)** — модель с высоким уровнем рассуждения:
- **Архитектура**: Проектирование системных решений, дизайн паттернов
- **Сложная логика**: Реализация бизнес-правил, алгоритмов, бэкенд-логики
- **Финальное качество**: Code Review, рефакторинг, оптимизация производительности
- **Критические решения**: Выбор технологий, архитектурные компромиссы

**Secondary Model (Gemini/Rapid)** — модель с быстрым откликом:
- **Быстрое прототипирование**: Создание MVP, UI/Frontend компонентов
- **Анализ больших контекстов**: Обработка больших объемов документации, логов
- **Рутинные задачи**: Генерация шаблонов, форматирование, документирование
- **Креативные задачи**: Генерация идей, вариантов UI, текстов

### Обязательный рабочий процесс (Mandatory Workflow)

1. **Планирование через Primary**: Любая новая задача начинается с анализа и планирования через Primary Model
2. **Делегирование рутины Secondary**: Рутинные операции делегируются Secondary Model для ускорения
3. **Ревью результата**: Primary Model критически проверяет результаты работы Secondary Model
4. **Итеративное улучшение**: При необходимости цикл повторяется до достижения требуемого качества

### Принципы делегирования

| Тип задачи | Рекомендуемая модель | Причина |
|---|---|---|
| Архитектурное проектирование | Primary | Требует глубокого анализа и системного мышления |
| Создание UI компонентов | Secondary | Быстрая генерация и итерации |
| Сложная бизнес-логика | Primary | Высокий риск ошибок, требуется точность |
| Анализ документации | Secondary | Обработка больших объемов данных |
| Code Review | Primary | Критическая оценка качества |
| Написание тестов | Secondary | Рутинная задача, шаблонизация |
| Рефакторинг | Primary | Понимание контекста и последствий |

### Parallel Subagents Strategy
Для ускорения работы используй стратегию параллельных субагентов (Map/Reduce):
1. **Map:** Декомпозируй большую задачу на независимые подзадачи (например, "написать тесты для модуля А", "написать тесты для модуля Б").
2. **Workers:** Создай отдельные `new_task` для каждой подзадачи.
3. **Reduce:** Собери результаты всех субагентов, проверь их и объедини.

### Prompt Engineering Techniques

**Prompt Repetition (Bidirectional Attention Simulation)**

Для повышения точности и автономности Secondary Models (Gemini/Haiku) в задачах без глубокого рассуждения (поиск, классификация, анализ больших данных) используйте технику **Prompt Repetition**.

*   **Суть:** Дублирование основного запроса в начале и в конце промпта.
*   **Формат:** `<QUERY> ... context ... <QUERY>`
*   **Зачем:** Устраняет "слепоту" модели к инструкциям, расположенным в начале длинного контекста, симулируя двустороннее внимание.
*   **Применение:** Критично при анализе логов, поиске по кодовой базе или классификации больших объемов текста.

---

## Структура проекта (Project Structure)

### `.kilocode/memory-bank/` (Глобальный контекст)
Эти файлы обновляются **Architect Mode** по завершении протоколов.

| Файл | Назначение |
|---|---|
| `index.md` | Точка входа, навигация по Memory Bank |
| `brief.md` | Краткое описание проекта, основные цели |
| `product.md` | "Зачем" и "Что". Цели продукта, проблемы пользователей, UX-принципы |
| `architecture.md` | "Как". Архитектурные решения, дизайн-паттерны, структура |
| `tech.md` | Стек технологий, зависимости, инструменты |
| `context.md` | Текущий фокус работы, статус, следующие шаги |

### `.kilocode/` (Правила агентов)
Централизованное хранилище правил и инструкций для Kilo Code.

### `.protocols/` (Локальный контекст задач)
Каждая задача или фича получает свою папку: `.protocols/YYYY-MM-DD-feature-name/`.

| Файл | Назначение |
|---|---|
| `brief.md` | Исходная задача, требования, критерии приемки (Definition of Done). |
| `plan.md` | Декомпозиция задачи на шаги (Todo List). Обновляется в процессе. |
| `execution.md` | Лог выполнения. Проблемы, решения, результаты тестов. |
| `context.md` | (Опционально) Специфический контекст для этой задачи (сниппеты, ссылки). |

---

## Рабочий процесс (Workflow)

### 1. Инициация задачи (Пользователь)
Пользователь формулирует задачу: "Хочу добавить авторизацию через Google"
(Для задач 1С см. [`1c-workflow.md`](1c-workflow.md))

### 2. Планирование (Architect Mode)
1. Читает `.kilocode/memory-bank/index.md` и `context.md`, подтверждая прочтение: [MB: OK].
2. Создает папку `.protocols/YYYY-MM-DD-feature-name/`
3. Создает `brief.md` (требования, критерии приемки)
4. Создает `plan.md` (декомпозиция на шаги)
5. Создает git-ветку `feat/feature-name`
6. **Переключается в Specialized Dev Mode** (соответствующий стеку, например `python-dev`, `1c-developer`).

### 3. Реализация (Specialized Dev Mode)
1. Читает `.protocols/.../plan.md`
2. Выполняет шаги из плана
3. Обновляет `plan.md` (отмечает выполненные пункты)
4. Записывает нюансы в `execution.md`
5. Запускает тесты
6. После завершения всех шагов запрашивает Architect Mode для ревью

### 4. Завершение (Architect Mode)
1. Проверяет код и `execution.md`
2. Если всё ок — мержит ветку
3. Обновляет `.kilocode/memory-bank/architecture.md` и `context.md`
4. Закрывает протокол
5. Сообщает пользователю о завершении

---

## Skills System

Перед началом любой задачи проверь доступные скиллы, прочитав [`.kilocode/rules/skills-index.md`](.kilocode/rules/skills-index.md). Используй скиллы для стандартизации рутинных операций (тесты, CLI).

### Принципы работы со скиллами

1. **Check First**: Перед началом ЛЮБОЙ задачи проверь `.kilocode/skills/` на наличие релевантных скиллов
2. **Apply Skill**: Если найден подходящий скилл — следуй его инструкциям
3. **Create New**: Если подходящего скилла нет — создай новый через workflow `.kilocode/workflows/create-new-skill.md`
4. **Integrate**: Скиллы должны работать в связке с Memory Bank и протоколами

### Когда использовать скиллы

- **Тестирование**: Используй скилл `project-tests.md` для стандартного процесса тестирования
- **CLI операции**: Используй скилл `cli-master.md` для безопасной работы с командной строкой
- **Рутина**: Любые повторяющиеся операции должны быть покрыты скиллами

### Интеграция с Memory Bank

При использовании скиллов всегда учитывай контекст из Memory Bank:
- [`tech.md`](../memory-bank/tech.md) — стек технологий проекта
- [`architecture.md`](../memory-bank/architecture.md) — архитектурные решения
- [`product.md`](../memory-bank/product.md) — цели продукта